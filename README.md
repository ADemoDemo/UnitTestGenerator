# Unit Test Generator #
 [![Build status](https://ci.appveyor.com/api/projects/status/5its63lms49x9cih?svg=true)](https://ci.appveyor.com/project/pcsikos/unittestgenerator) [![Coverage Status](https://coveralls.io/repos/pcsikos/UnitTestGenerator/badge.svg?branch=master&service=github)](https://coveralls.io/github/pcsikos/UnitTestGenerator?branch=master)

The primary purpose of **Unit Test Generator** is to generate repetative and boring copy/paste unit tests such as null argument check. Tests are generated by means of [T4 text template](https://msdn.microsoft.com/en-us/library/bb126445.aspx).  Process of the code generation consists from three parts. 

 1. Method body generation
 2. Method name generation
 3. Test Class source code generation (T4)

Each part of code generation can be customized. Tests mostly validate whether an ArgumentNullException was thrown. Therefore T4 template and method body generation will fit for most developers and unit test frameworks(changing test method attribute in T4 does not counts or hurts :). With the generation of method name it is a different case. For the test method naming was the [Roy Osherove's naming strategy](http://osherove.com/blog/2005/4/3/naming-standards-for-unit-tests.html) used. However this can be changed by your own implementation. About that later.
You can find more examples of generated tests in the [repository](src/UnitTestGenerator.Tests/ArgumentTest.cs).

Generated test may look like:
```c#
     [TestMethod]
     [ExpectedException(typeof(System.ArgumentNullException))]
     public void IsValidIdentifier_VarNameNullValueGiven_ShouldThrowArgumentNullException()
     {
         var cSharpIdentifierValidator = new CSharpIdentifierValidator();		 
         cSharpIdentifierValidator.IsValidIdentifier(null);		 
     }
```

# Getting started #

    PM> Install-Package UnitTestGenerator

When you have your own test generators code usage should look like this:
```c#
var assemblyTraverser = new AssemblyTraverser(typeof(MyClass).Assembly, x => true, false);
var testClassBuilder = new TestClassBuilder(assemblyTraverser, /* enumeration of test generators */);
var classes = testClassBuilder.BuildTestClasses();
```

Wiring up test generators with dependencies could be a skull breaker, therefore for new commers a simpler way of usage was introduced:

```
var testClassBuilder = typeof(CustomAssembly.Class1).Assembly
               .ComposeTestClassBuilder("CustomAssembly.Tests", configure: configure => configure
                        .IncludeBuiltinGenerators());

 foreach(var testClass in generator.BuildTestClasses())
 {
#> <--- T4 mark up
        namespace <#= TranslateNamespace(testClass.TestedType.Namespace) #>
        {
            [TestClass]
            public partial class <#= testClass.TestedType.Name #>Tests
            {                             
            ...
            ...
```

For the syntax above you will need to install package UnitTestGenerator.Extensions.Composition to make it work. 

    PM> Install-Package UnitTestGenerator.Extensions.Composition

It will install basic T4 template or you can use direct [link](nuget/ArgumentCheck.tt). 

# Why

Are you you asking yourself why on Earth would you generate tests at all? Yes, it is againts the [idea](http://stackoverflow.com/questions/357059/unit-test-case-generator) of unit tests. Discussions about generating unit tests always tends to end with conclusions that it is a bad idea. Yes, that is true, however this is not that case. **Unit Test Generator** only analyzes the signature of methods not their bodies and regarding that generates test methods to validate whether null arguments are handled properly. It does exactly that, what developer would do when they would write argument validation tests. Benefit from **Unit Test Generator** is time saving(each nullable parameter leads to another test) and it avoids human errors when tests are manually written (forgeting writing test for new methods, argument checks for new parameters in existing methods, etc.). 

# When

Most suitable for Unit Test Generator is [Domain Driven Design](https://en.wikipedia.org/wiki/Domain-driven_design) when you need test arguments of methods and constructors as well for null reference. Service classes needs mostly be tested for null refenrence only in methods, because constructors are handled by IoC containers and thus do not need argument validation. At least not for null reference.

# Advanced Scenarios

##Custom source code generation
>Comming soon

##Custom method name generation
>Comming soon

##Using own unit test generator
>Comming soon

##Configuring ClassBuilder composition
>Comming soon

# Issues

It is higly likely that not all code generation issues were handled. Issue reports are extremely usefull. 

Reviews, pull requests, forks and stars are welcome :)
